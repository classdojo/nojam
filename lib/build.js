// Generated by CoffeeScript 1.6.2
(function() {
  var amdify, async, at, dref, fs, glob, outcome, path, spawn, stepc;

  amdify = require("amdify");

  at = amdify.transformers;

  async = require("async");

  stepc = require("stepc");

  outcome = require("outcome");

  fs = require("fs");

  path = require("path");

  dref = require("dref");

  spawn = require("child_process").spawn;

  glob = require("glob");

  module.exports = (function() {
    /*
    */
    function _Class(ops, packageManagers) {
      var baseDir, _ref;

      this.ops = ops;
      this._jam = packageManagers.packageManagers.jam;
      this._directory = process.cwd();
      this._ignore = ((_ref = ops.nojam) != null ? _ref.ignore : void 0) || [];
      this._prefix = dref.get(ops.pkg, "jam.packageDir") || "jam";
      baseDir = dref.get(ops.pkg, "jam.baseUrl") || "";
      this._output = this._directory + "/" + this._prefix;
      this._prefix = this._prefix.replace(new RegExp("^" + baseDir), "");
      this._baseDir = this._directory + "/" + baseDir;
      this._usedDeps = glob.sync("**", {
        cwd: this._output
      });
    }

    /*
    */


    _Class.prototype.run = function(callback) {
      var _this = this;

      return this._rebuildDir(this._directory, function() {
        return _this._buildJamDeps(function() {
          return _this._jam.rebuild(callback);
        });
      });
    };

    /*
    */


    _Class.prototype._buildJamDeps = function(callback) {
      var self;

      self = this;
      return stepc.async((function() {
        return fs.readdir(self._output, this);
      }), (function(err, dirs) {
        if (dirs == null) {
          dirs = [];
        }
        self._fixPackages(dirs);
        return async.eachSeries(dirs, (function(dir, next) {
          console.log("install %s", dir);
          if (self._checkIgnore(dir, next)) {
            return;
          }
          if (dir === ".DS_Store") {
            return next();
          }
          if (!fs.lstatSync(self._output + "/" + dir).isDirectory()) {
            return next();
          }
          return self._rebuildDir(self._output + "/" + dir, next);
        }), this);
      }), callback);
    };

    /*
    */


    _Class.prototype._rebuildDir = function(dir, callback) {
      var deps, fdir, nodeModulesDir, pkg, pkgPath, self, _ref, _ref1, _ref2, _ref3;

      if (this._checkIgnore(dir, callback)) {
        return;
      }
      fdir = dir;
      pkgPath = fdir + "/package.json";
      nodeModulesDir = fdir + "/node_modules";
      if (!fs.existsSync(pkgPath)) {
        return callback();
      }
      pkg = require(pkgPath);
      deps = Object.keys((_ref = (_ref1 = (_ref2 = pkg.nojam) != null ? _ref2.dependencies : void 0) != null ? _ref1 : pkg.dependencies) != null ? _ref : {});
      this._ignore = (((_ref3 = pkg.nojam) != null ? _ref3.ignore : void 0) || []).concat(this._ignore || []);
      if (!deps.length) {
        return callback();
      }
      self = this;
      return stepc.async((function() {
        var _this = this;

        return spawn("npm", ["install"], {
          cwd: fdir
        }).once("close", function() {
          return _this();
        });
      }), (function() {
        return fs.readdir(nodeModulesDir, this);
      }), (function(err, dirs) {
        if (dirs == null) {
          dirs = [];
        }
        dirs = dirs.filter(function(dir) {
          return ~deps.indexOf(dir) && !fs.existsSync(self._output + "/" + dir);
        });
        return async.eachSeries(dirs, (function(dir, next) {
          var fp;

          if (/\.bin|\.DS_Store/.test(dir)) {
            return next();
          }
          fp = nodeModulesDir + "/" + dir;
          console.log("install %s", dir);
          if (self._checkIgnore(dir, next)) {
            return;
          }
          return self._amdify(fp, function() {
            return next();
          });
        }), this);
      }), callback);
    };

    /*
    */


    _Class.prototype._fixPackages = function(dirs) {
      var dir, name, pkgPath, _i, _len, _results;

      _results = [];
      for (_i = 0, _len = dirs.length; _i < _len; _i++) {
        name = dirs[_i];
        dir = this._output + "/" + name;
        pkgPath = dir + "/package.json";
        if (!fs.lstatSync(dir).isDirectory()) {
          continue;
        }
        if (!fs.existsSync(pkgPath)) {
          console.log("writing package %s", pkgPath);
          _results.push(fs.writeFileSync(pkgPath, JSON.stringify({
            name: name,
            description: name
          }, null, 2), "utf8"));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    /*
    */


    _Class.prototype._checkIgnore = function(dir, next) {
      if (~this._ignore.indexOf(dir)) {
        console.log("skip %s", dir);
        next();
        return true;
      }
      return false;
    };

    /*
    */


    _Class.prototype._fixDirs = function(base, dirs) {
      return dirs.map(function(d) {
        var pt, stat;

        pt = base + "/" + d;
        while ((stat = fs.lstatSync(pt)).isSymbolicLink()) {
          pt = fs.readlinkSync(pt);
        }
        return pt;
      }).filter(function(d) {
        return path.basename(d).substr(0, 1) !== "." && fs.lstatSync(d).isDirectory();
      });
    };

    /*
    */


    _Class.prototype._amdify = function(dir, callback) {
      var _this = this;

      if (this._checkIgnore(dir, callback)) {
        return;
      }
      return amdify({
        entry: require.resolve(dir),
        prefix: ""
      }, outcome.e(callback).s(function(bundle) {
        var transformer;

        transformer = new at.Template("amd");
        transformer = new at.Copy({
          output: _this._output
        }, transformer);
        transformer.filter(function(dep) {
          if (~_this._usedDeps.indexOf(dep.alias)) {
            return false;
          } else {
            return _this._usedDeps.push(dep.alias);
          }
        });
        return bundle.transform(transformer, callback);
      }));
    };

    return _Class;

  })();

}).call(this);
