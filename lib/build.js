// Generated by CoffeeScript 1.6.2
(function() {
  var amdify, async, at, dref, fs, outcome, path, spawn, stepc;

  amdify = require("amdify");

  at = amdify.transformers;

  async = require("async");

  stepc = require("stepc");

  outcome = require("outcome");

  fs = require("fs");

  path = require("path");

  dref = require("dref");

  spawn = require("child_process").spawn;

  module.exports = (function() {
    /*
    */
    function _Class(ops, packageManagers) {
      var baseDir;

      this.ops = ops;
      this._jam = packageManagers.packageManagers.jam;
      this._directory = process.cwd();
      this._prefix = dref.get(ops.pkg, "jam.packageDir") || "jam";
      baseDir = dref.get(ops.pkg, "jam.baseUrl") || "";
      this._output = this._directory + "/" + this._prefix;
      this._prefix = this._prefix.replace(new RegExp("^" + baseDir), "");
      this._baseDir = this._directory + "/" + baseDir;
      this._usedDeps = {};
    }

    /*
    */


    _Class.prototype.run = function(callback) {
      var _this = this;

      return this._buildJamDeps(function() {
        return _this._jam.rebuild(callback);
      });
      /*
      o = outcome.e callback
      dir = @_directory + "/node_modules"
      output = @_output
      self = @
      
      
      stepc.async(
        (() ->
          fs.readdir dir, @
        ),
        ((err, dirs = []) ->
      
          if self.ops.pkg.nojam?.ignoreNodeModules
            return this null, []
      
          this null, self._fixDirs(dir, dirs)
        ),
        (o.s (dirs) ->
          this.dirs = dirs
          self._amdifyAll dirs, this
        ),
        (o.s () ->
          self._fixPackage this.dirs, this
        ),
        (o.s () ->
          self._jam.rebuild @
        ),
        callback
      )
      */

    };

    /*
    */


    _Class.prototype._buildJamDeps = function(callback) {
      var self;

      self = this;
      return stepc.async((function() {
        return fs.readdir(self._output, this);
      }), (function(err, dirs) {
        if (dirs == null) {
          dirs = [];
        }
        return async.eachSeries(dirs, (function(dir, next) {
          if (dir === ".DS_Store") {
            return next();
          }
          if (!fs.lstatSync(self._output + "/" + dir).isDirectory()) {
            return next();
          }
          return self._rebuildDir(dir, next);
        }), this);
      }), callback);
    };

    /*
    */


    _Class.prototype._rebuildDir = function(dir, callback) {
      var deps, fdir, nodeModulesDir, pkg, pkgPath, self;

      fdir = this._output + "/" + dir;
      pkgPath = fdir + "/package.json";
      nodeModulesDir = fdir + "/node_modules";
      pkg = require(pkgPath);
      if (!pkg.dependencies) {
        return callback();
      }
      self = this;
      deps = Object.keys(pkg.dependencies).filter(function(dep) {
        return !fs.existsSync(self._output + "/" + dep);
      });
      return stepc.async((function() {
        var _this = this;

        if (fs.existsSync(nodeModulesDir)) {
          return this();
        }
        return spawn("npm", ["install"], {
          cwd: fdir
        }).once("close", function() {
          return _this();
        });
      }), (function() {
        return fs.readdir(nodeModulesDir, this);
      }), (function(err, dirs) {
        if (dirs == null) {
          dirs = [];
        }
        return async.eachSeries(deps, (function(dir, next) {
          var fp;

          if (/\.bin|\.DS_Store/.test(dir)) {
            return next();
          }
          fp = nodeModulesDir + "/" + dir;
          return self._amdify(fp, next);
        }), this);
      }), callback);
    };

    /*
    */


    _Class.prototype._fixPackage = function(dirs, next) {
      var d, pkgPath,
        _this = this;

      return next();
      d = {};
      dirs.map(function(dir) {
        var bn;

        bn = path.basename(dir);
        return d[bn] = path.join(_this._prefix, bn, require.resolve(dir).replace(dir, "").replace(".js", ""));
      });
      dref.set(this.ops.pkg, "jam.config.paths", d);
      pkgPath = path.join(this.ops.dir, "package.json");
      return fs.writeFile(pkgPath, JSON.stringify(this.ops.pkg, null, 2), next);
    };

    /*
    */


    _Class.prototype._fixDirs = function(base, dirs) {
      return dirs.map(function(d) {
        var pt, stat;

        pt = base + "/" + d;
        while ((stat = fs.lstatSync(pt)).isSymbolicLink()) {
          pt = fs.readlinkSync(pt);
        }
        return pt;
      }).filter(function(d) {
        return path.basename(d).substr(0, 1) !== "." && fs.lstatSync(d).isDirectory();
      });
    };

    /*
    */


    _Class.prototype._amdifyAll = function(dirs, callback) {
      var _this = this;

      return async.map(dirs, (function(dir, callback) {
        return _this._amdify(dir, function(err) {
          return callback();
        });
      }), callback);
    };

    /*
    */


    _Class.prototype._amdify = function(dir, callback) {
      var _this = this;

      return amdify({
        entry: require.resolve(dir),
        prefix: ""
      }, outcome.e(callback).s(function(bundle) {
        var transformer;

        transformer = new at.Template("amd");
        transformer = new at.Copy({
          output: _this._output
        }, transformer);
        transformer.filter(function(dep) {
          if (_this._usedDeps[dep.alias]) {
            return false;
          } else {
            return _this._usedDeps[dep.alias] = true;
          }
        });
        return bundle.transform(transformer, callback);
      }));
    };

    return _Class;

  })();

}).call(this);
